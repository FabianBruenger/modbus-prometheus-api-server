"use strict";require("source-map-support").install();var de=de||{biancoroyal:{modbus:{core:{client:{}}}}};de.biancoroyal.modbus.core.client.internalDebug=de.biancoroyal.modbus.core.client.internalDebug||require("debug")("contribModbus:core:client"),de.biancoroyal.modbus.core.client.internalDebugFSM=de.biancoroyal.modbus.core.client.internalDebugFSM||require("debug")("contribModbus:core:client:fsm"),de.biancoroyal.modbus.core.client.modbusSerialDebug=de.biancoroyal.modbus.core.client.modbusSerialDebug||require("debug")("modbus-serial"),de.biancoroyal.modbus.core.client.XStateFSM=de.biancoroyal.modbus.core.client.XStateFSM||require("@xstate/fsm"),de.biancoroyal.modbus.core.client.stateLogEnabled=de.biancoroyal.modbus.core.client.stateLogEnabled||!1,de.biancoroyal.modbus.core.client.networkErrors=["ESOCKETTIMEDOUT","ETIMEDOUT","ECONNRESET","ENETRESET","ECONNABORTED","ECONNREFUSED","ENETUNREACH","ENOTCONN","ESHUTDOWN","EHOSTDOWN","ENETDOWN","EWOULDBLOCK","EAGAIN","EHOSTUNREACH"],de.biancoroyal.modbus.core.client.createStateMachineService=function(){return this.stateLogEnabled=!1,this.XStateFSM.createMachine({id:"modbus",initial:"new",states:{new:{on:{INIT:"init",BREAK:"broken",STOP:"stopped"}},broken:{on:{INIT:"init",STOP:"stopped",FAILURE:"failed",ACTIVATE:"activated",RECONNECT:"reconnecting"}},reconnecting:{on:{INIT:"init",STOP:"stopped"}},init:{on:{OPENSERIAL:"opened",CONNECT:"connected",BREAK:"broken",FAILURE:"failed",STOP:"stopped",SWITCH:"switch"}},opened:{on:{CONNECT:"connected",BREAK:"broken",FAILURE:"failed",CLOSE:"closed",STOP:"stopped",SWITCH:"switch"}},connected:{on:{CLOSE:"closed",ACTIVATE:"activated",QUEUE:"queueing",BREAK:"broken",FAILURE:"failed",STOP:"stopped",SWITCH:"switch"}},activated:{on:{READ:"reading",WRITE:"writing",QUEUE:"queueing",BREAK:"broken",CLOSE:"closed",FAILURE:"failed",STOP:"stopped",SWITCH:"switch"}},queueing:{on:{ACTIVATE:"activated",SEND:"sending",READ:"reading",WRITE:"writing",EMPTY:"empty",BREAK:"broken",CLOSE:"closed",FAILURE:"failed",STOP:"stopped",SWITCH:"switch"}},empty:{on:{QUEUE:"queueing",BREAK:"broken",FAILURE:"failed",CLOSE:"closed",STOP:"stopped",SWITCH:"switch"}},sending:{on:{ACTIVATE:"activated",READ:"reading",WRITE:"writing",BREAK:"broken",FAILURE:"failed",STOP:"stopped",SWITCH:"switch"}},reading:{on:{ACTIVATE:"activated",BREAK:"broken",FAILURE:"failed",STOP:"stopped"}},writing:{on:{ACTIVATE:"activated",BREAK:"broken",FAILURE:"failed",STOP:"stopped"}},closed:{on:{FAILURE:"failed",BREAK:"broken",CONNECT:"connected",RECONNECT:"reconnecting",INIT:"init",STOP:"stopped",SWITCH:"switch"}},failed:{on:{CLOSE:"closed",BREAK:"broken",STOP:"stopped",SWITCH:"switch"}},switch:{on:{CLOSE:"closed",BREAK:"broken",STOP:"stopped"}},stopped:{on:{NEW:"new",STOP:"stopped"}}}})},de.biancoroyal.modbus.core.client.getActualUnitId=function(e,n){return n.payload&&Number.isInteger(n.payload.unitid)?parseInt(n.payload.unitid):Number.isInteger(n.queueUnitId)?parseInt(n.queueUnitId):parseInt(e.unit_id)||0},de.biancoroyal.modbus.core.client.startStateService=function(e){return this.XStateFSM.interpret(e).start()},de.biancoroyal.modbus.core.client.checkUnitId=function(e,n){return"tcp"===n?0<=e&&e<=255:0<=e&&e<=247},de.biancoroyal.modbus.core.client.getLogFunction=function(e){return e.internalDebugLog||de.biancoroyal.modbus.core.client.internalDebug},de.biancoroyal.modbus.core.client.activateSendingOnSuccess=function(e,n,t,a,o){e.activateSending(o).then(function(){n(a,o)}).catch(function(e){t(e,o)}).finally(function(){e.stateService.send("ACTIVATE")})},de.biancoroyal.modbus.core.client.activateSendingOnFailure=function(e,n,t,a){e.activateSending(a).then(function(){n(t,a)}).catch(function(e){n(e,a)}).finally(function(){e.stateService.send("ACTIVATE")})},de.biancoroyal.modbus.core.client.readModbusByFunctionCodeOne=function(n,t,a,o){var i=de.biancoroyal.modbus.core.client;n.client.readCoils(parseInt(t.payload.address),parseInt(t.payload.quantity)).then(function(e){i.activateSendingOnSuccess(n,a,o,e,t)}).catch(function(e){i.activateSendingOnFailure(n,o,new Error(e.message),t),n.modbusErrorHandling(e)})},de.biancoroyal.modbus.core.client.readModbusByFunctionCodeTwo=function(n,t,a,o){var i=de.biancoroyal.modbus.core.client;n.client.readDiscreteInputs(parseInt(t.payload.address),parseInt(t.payload.quantity)).then(function(e){i.activateSendingOnSuccess(n,a,o,e,t)}).catch(function(e){i.activateSendingOnFailure(n,o,new Error(e.message),t),n.modbusErrorHandling(e)})},de.biancoroyal.modbus.core.client.readModbusByFunctionCodeThree=function(n,t,a,o){var i=de.biancoroyal.modbus.core.client;n.client.readHoldingRegisters(parseInt(t.payload.address),parseInt(t.payload.quantity)).then(function(e){i.activateSendingOnSuccess(n,a,o,e,t)}).catch(function(e){i.activateSendingOnFailure(n,o,new Error(e.message),t),n.modbusErrorHandling(e)})},de.biancoroyal.modbus.core.client.readModbusByFunctionCodeFour=function(n,t,a,o){var i=de.biancoroyal.modbus.core.client;n.client.readInputRegisters(parseInt(t.payload.address),parseInt(t.payload.quantity)).then(function(e){i.activateSendingOnSuccess(n,a,o,e,t)}).catch(function(e){i.activateSendingOnFailure(n,o,new Error(e.message),t),n.modbusErrorHandling(e)})},de.biancoroyal.modbus.core.client.readModbusByFunctionCode=function(e,n,t,a){var o=de.biancoroyal.modbus.core.client,i=de.biancoroyal.modbus.core.client.getLogFunction(e);switch(parseInt(n.payload.fc)){case 1:o.readModbusByFunctionCodeOne(e,n,t,a);break;case 2:o.readModbusByFunctionCodeTwo(e,n,t,a);break;case 3:o.readModbusByFunctionCodeThree(e,n,t,a);break;case 4:o.readModbusByFunctionCodeFour(e,n,t,a);break;default:o.activateSendingOnFailure(e,a,new Error("Function Code Unknown"),n),i("Function Code Unknown %s",n.payload.fc)}},de.biancoroyal.modbus.core.client.readModbus=function(n,t,e,a){var o=de.biancoroyal.modbus.core.client,i=de.biancoroyal.modbus.core.client.getLogFunction(n),r=1;if(n.client){if(n.client._port&&n.client._port._client&&!n.client._port._client.readable){if(!n.connectClient())return void o.activateSendingOnFailure(n,a,new Error("Modbus-Read Error from client connecting"),t);r=500}setTimeout(function(){n.bufferCommands?n.queueLog(JSON.stringify({info:"read msg via Modbus",message:t.payload,queueUnitId:t.queueUnitId,timeout:n.client.getTimeout(),state:n.actualServiceState.value})):"tcp"!==n.clienttype&&n.stateService.send("READ"),n.setUnitIdFromPayload(t),n.client.setTimeout(n.clientTimeout);try{o.readModbusByFunctionCode(n,t,e,a)}catch(e){o.activateSendingOnFailure(n,a,e,t),i(e.message),n.modbusErrorHandling(e)}},r)}else i("Client Not Ready As Object On Reading Modbus")},de.biancoroyal.modbus.core.client.writeModbusByFunctionCodeFive=function(t,a,o,i){var r=de.biancoroyal.modbus.core.client;a.payload.value?a.payload.value=!0:a.payload.value=!1,t.client.writeCoil(parseInt(a.payload.address),a.payload.value).then(function(e){r.activateSendingOnSuccess(t,o,i,e,a)}).catch(function(e){var n;0===t.client.getID()?(n={address:parseInt(a.payload.address),value:parseInt(a.payload.value)},r.activateSendingOnSuccess(t,o,i,n,a)):(r.activateSendingOnFailure(t,i,e,a),t.modbusErrorHandling(e))})},de.biancoroyal.modbus.core.client.writeModbusByFunctionCodeFifteen=function(t,a,o,i){var r=de.biancoroyal.modbus.core.client;parseInt(a.payload.value.length)!==parseInt(a.payload.quantity)?r.activateSendingOnFailure(t,i,new Error("Quantity should be less or equal to coil payload array length: "+a.payload.value.length+" Addr: "+a.payload.address+" Q: "+a.payload.quantity),a):t.client.writeCoils(parseInt(a.payload.address),a.payload.value).then(function(e){r.activateSendingOnSuccess(t,o,i,e,a)}).catch(function(e){var n;0===t.client.getID()?(n={address:parseInt(a.payload.address),value:parseInt(a.payload.value)},r.activateSendingOnSuccess(t,o,i,n,a)):(r.activateSendingOnFailure(t,i,e,a),t.modbusErrorHandling(e))})},de.biancoroyal.modbus.core.client.writeModbusByFunctionCodeSix=function(t,a,o,i){var r=de.biancoroyal.modbus.core.client;t.client.writeRegister(parseInt(a.payload.address),parseInt(a.payload.value)).then(function(e){r.activateSendingOnSuccess(t,o,i,e,a)}).catch(function(e){var n;0===t.client.getID()?(n={address:parseInt(a.payload.address),value:parseInt(a.payload.value)},r.activateSendingOnSuccess(t,o,i,n,a)):(r.activateSendingOnFailure(t,i,e,a),t.modbusErrorHandling(e))})},de.biancoroyal.modbus.core.client.writeModbusByFunctionCodeSixteen=function(t,a,o,i){var r=de.biancoroyal.modbus.core.client;parseInt(a.payload.value.length)!==parseInt(a.payload.quantity)?r.activateSendingOnFailure(t,i,new Error("Quantity should be less or equal to register payload array length: "+a.payload.value.length+" Addr: "+a.payload.address+" Q: "+a.payload.quantity),a):t.client.writeRegisters(parseInt(a.payload.address),a.payload.value).then(function(e){r.activateSendingOnSuccess(t,o,i,e,a)}).catch(function(e){var n;0===t.client.getID()?(n={address:parseInt(a.payload.address),value:parseInt(a.payload.value)},r.activateSendingOnSuccess(t,o,i,n,a)):(r.activateSendingOnFailure(t,i,e,a),t.modbusErrorHandling(e))})},de.biancoroyal.modbus.core.client.writeModbus=function(n,t,e,a){var o=de.biancoroyal.modbus.core.client,i=de.biancoroyal.modbus.core.client.getLogFunction(n),r=1;if(n.client){if(n.client._port&&n.client._port._client&&!n.client._port._client.writable){if(!n.connectClient())return void o.activateSendingOnFailure(n,a,new Error("Modbus-Read Error from client connecting"),t);r=500}setTimeout(function(){n.bufferCommands?n.queueLog(JSON.stringify({info:"write msg",message:t.payload,queueUnitId:t.queueUnitId,timeout:n.client.getTimeout(),state:n.actualServiceState.value})):"tcp"!==n.clienttype&&n.stateService.send("WRITE"),n.setUnitIdFromPayload(t),n.client.setTimeout(n.clientTimeout);try{switch(parseInt(t.payload.fc)){case 15:o.writeModbusByFunctionCodeFifteen(n,t,e,a);break;case 5:o.writeModbusByFunctionCodeFive(n,t,e,a);break;case 16:o.writeModbusByFunctionCodeSixteen(n,t,e,a);break;case 6:o.writeModbusByFunctionCodeSix(n,t,e,a);break;default:o.activateSendingOnFailure(n,a,new Error("Function Code Unknown"),t),i("Function Code Unknown %s",t.payload.fc)}}catch(e){o.activateSendingOnFailure(n,a,e,t),i(e.message),n.modbusErrorHandling(e)}},r)}else i("Client Not Ready As Object On Writing Modbus")},de.biancoroyal.modbus.core.client.setNewTCPNodeSettings=function(e,n){e.clienttype="tcp",e.tcpHost=n.payload.tcpHost||e.tcpHost,e.tcpPort=n.payload.tcpPort||e.tcpPort,e.tcpType=n.payload.tcpType||e.tcpType},de.biancoroyal.modbus.core.client.setNewSerialNodeSettings=function(e,n){n.payload.serialPort&&(e.serialPort=n.payload.serialPort||e.serialPort),n.payload.serialBaudrate&&(e.serialBaudrate=parseInt(n.payload.serialBaudrate)||e.serialBaudrate),e.clienttype="serial",e.serialDatabits=n.payload.serialDatabits||e.serialDatabits,e.serialStopbits=n.payload.serialStopbits||e.serialStopbits,e.serialParity=n.payload.serialParity||e.serialParity,e.serialType=n.payload.serialType||e.serialType,n.payload.serialAsciiResponseStartDelimiter&&"string"==typeof n.payload.serialAsciiResponseStartDelimiter?e.serialAsciiResponseStartDelimiter=parseInt(n.payload.serialAsciiResponseStartDelimiter,16):e.serialAsciiResponseStartDelimiter=n.payload.serialAsciiResponseStartDelimiter||e.serialAsciiResponseStartDelimiter,n.payload.serialConnectionDelay&&(e.serialConnectionDelay=parseInt(n.payload.serialConnectionDelay)||e.serialConnectionDelay)},de.biancoroyal.modbus.core.client.setNewNodeOptionalSettings=function(e,n){var t=de.biancoroyal.modbus.core.client.getLogFunction(e);try{var a=parseInt(n.payload.unitId);e.checkUnitId(a,e.clienttype)||(a=e.unit_id),e.unit_id=a}catch(e){t(e.message)}n.payload.commandDelay&&(e.commandDelay=parseInt(n.payload.commandDelay)||e.commandDelay),n.payload.clientTimeout&&(e.clientTimeout=parseInt(n.payload.clientTimeout)||e.clientTimeout),n.payload.reconnectTimeout&&(e.reconnectTimeout=parseInt(n.payload.reconnectTimeout)||e.reconnectTimeout)},de.biancoroyal.modbus.core.client.setNewNodeSettings=function(e,n){var t=de.biancoroyal.modbus.core.client.getLogFunction(e),a=de.biancoroyal.modbus.core.client;if(!n)return t("New Connection message invalid."),!1;switch(n.payload.connectorType.toUpperCase()){case"TCP":a.setNewTCPNodeSettings(e,n),t("New Connection TCP Settings "+e.tcpHost+" "+e.tcpPort+" "+e.tcpType);break;case"SERIAL":a.setNewSerialNodeSettings(e,n),t("New Connection Serial Settings "+e.serialPort+" "+e.serialBaudrate+" "+e.serialType);break;default:t("Unknown Dynamic Reconnect Type "+n.payload.connectorType)}return a.setNewNodeOptionalSettings(e,n),!0},de.biancoroyal.modbus.core.client.messageAllowedStates=["activated","queueing","sending","empty","connected"],module.exports=de.biancoroyal.modbus.core.client;
//# sourceMappingURL=../maps/core/modbus-client-core.js.map
