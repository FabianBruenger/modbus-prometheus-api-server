{"version":3,"sources":["modbus-flex-sequencer.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","nodes","registerType","config","internalDebugLog","createNode","this","name","sequences","showStatusActivities","showErrors","showWarnings","connection","ioFile","getNode","useIOForPayload","logIOActivities","emptyMsgOnFail","verboseLogging","settings","delayOnStart","startDelayTime","parseInt","node","bufferMessageList","INPUT_TIMEOUT_MILLISECONDS","inputDelayTimer","onModbusReadDone","Map","modbusClient","registerForModbus","server","verboseWarn","logMessage","initializeInputDelayTimer","warn","mbIOCore","buildMessageWithIO","emit","errorProtocolMsg","err","msg","logMsgError","onModbusReadError","resp","data","sendEmptyMsgOnFail","setModbusError","message","origMsg","getOriginalMessage","fc","prepareMsg","JSON","parse","unitid","address","quantity","isValidModbusMsg","isValid","error","isInteger","buildNewMessageObject","Number","topic","messageId","payload","keepMsgProperties","verbose","isReadyForInput","isNotReadyForInput","resetInputDelayTimer","getObjectId","clearTimeout","delayOccured","setTimeout","isActive","origMsgInput","id","setNodeStatusTo","deregisterForModbus","invalidPayloadIn","isInactive","Object","assign","invalidSequencesIn","forEach","newMsg","inputMsg","set","buildNewMessage","actualServiceState","on","done","clear","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-flex-sequencer.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a>Andrea Verardi</a> (Anversoft)\n */\n\n/**\n * Modbus Sequencer node.\n * @module NodeRedModbusFlexSequencer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const mbCore = require('./core/modbus-core')\n  const mbIOCore = require('./core/modbus-io-core')\n  const internalDebugLog = require('debug')('contribModbus:poller')\n\n  function ModbusFlexSequencer (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.sequences = config.sequences\n\n    this.showStatusActivities = config.showStatusActivities\n    this.showErrors = config.showErrors\n    this.showWarnings = config.showWarnings\n    this.connection = null\n\n    this.useIOFile = config.useIOFile\n    this.ioFile = RED.nodes.getNode(config.ioFile)\n    this.useIOForPayload = config.useIOForPayload\n    this.logIOActivities = config.logIOActivities\n\n    this.emptyMsgOnFail = config.emptyMsgOnFail\n    this.keepMsgProperties = config.keepMsgProperties\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    this.delayOnStart = config.delayOnStart\n    this.startDelayTime = parseInt(config.startDelayTime) || 10\n\n    const node = this\n    node.bufferMessageList = new Map()\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\n    node.delayOccured = false\n    node.inputDelayTimer = null\n\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n    mbBasics.initModbusClientEvents(node, modbusClient)\n\n    node.onModbusReadDone = function (resp, msg) {\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo('reading done', node)\n      }\n\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\n      node.emit('modbusFlexSequencerNodeDone')\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.onModbusReadError = function (err, msg) {\n      node.internalDebugLog(err.message)\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\n      node.errorProtocolMsg(err, origMsg)\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\n      node.emit('modbusFlexSequencerNodeError')\n    }\n\n    node.prepareMsg = function (msg) {\n      if (typeof msg === 'string') {\n        msg = JSON.parse(msg)\n      }\n\n      switch (msg.fc) {\n        case 'FC1':\n          msg.fc = 1\n          break\n        case 'FC2':\n          msg.fc = 2\n          break\n        case 'FC3':\n          msg.fc = 3\n          break\n        case 'FC4':\n          msg.fc = 4\n          break\n      }\n\n      msg.unitid = parseInt(msg.unitid)\n      msg.address = parseInt(msg.address) || 0\n      msg.quantity = parseInt(msg.quantity) || 1\n\n      return msg\n    }\n\n    node.isValidModbusMsg = function (msg) {\n      let isValid = true\n\n      if (!(Number.isInteger(msg.unitid) &&\n          msg.unitid >= 0 &&\n          msg.unitid <= 255)) {\n        node.error('Unit ID Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n        !(Number.isInteger(msg.address) &&\n          msg.address >= 0 &&\n          msg.address <= 65535)) {\n        node.error('Address Not Valid', msg)\n        isValid &= false\n      }\n\n      if (isValid &&\n        !(Number.isInteger(msg.quantity) &&\n          msg.quantity >= 1 &&\n          msg.quantity <= 65535)) {\n        node.error('Quantity Not Valid', msg)\n        isValid &= false\n      }\n\n      return isValid\n    }\n\n    node.buildNewMessageObject = function (node, msg) {\n      const messageId = mbCore.getObjectId()\n      return {\n        topic: msg.topic || node.id,\n        messageId,\n        payload: {\n          name: msg.name,\n          unitid: msg.unitid,\n          fc: msg.fc,\n          address: msg.address,\n          quantity: msg.quantity,\n          emptyMsgOnFail: node.emptyMsgOnFail,\n          keepMsgProperties: node.keepMsgProperties,\n          messageId\n        }\n      }\n    }\n\n    function verboseWarn (logMessage) {\n      if (RED.settings.verbose && node.showWarnings) {\n        node.warn('Flex-Sequencer -> ' + logMessage)\n      }\n    }\n\n    node.isReadyForInput = function () {\n      return (modbusClient.client && modbusClient.isActive() && node.delayOccured)\n    }\n\n    node.isNotReadyForInput = function () {\n      return !node.isReadyForInput()\n    }\n\n    node.resetInputDelayTimer = function () {\n      if (node.inputDelayTimer) {\n        verboseWarn('reset input delay timer node ' + node.id)\n        clearTimeout(node.inputDelayTimer)\n      }\n      node.inputDelayTimer = null\n      node.delayOccured = false\n    }\n\n    node.initializeInputDelayTimer = function () {\n      node.resetInputDelayTimer()\n      if (node.delayOnStart) {\n        verboseWarn('initialize input delay timer node ' + node.id)\n        node.inputDelayTimer = setTimeout(() => {\n          node.delayOccured = true\n        }, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\n      } else {\n        node.delayOccured = true\n      }\n    }\n\n    node.initializeInputDelayTimer()\n\n    node.on('input', function (msg) {\n      if (mbBasics.invalidPayloadIn(msg)) {\n        verboseWarn('Invalid message on input.')\n        return\n      }\n\n      if (node.isNotReadyForInput()) {\n        verboseWarn('Inject while node is not ready for input.')\n        return\n      }\n\n      if (modbusClient.isInactive()) {\n        verboseWarn('You sent an input to inactive client. Please use initial delay on start or send data more slowly.')\n        return\n      }\n\n      const origMsgInput = Object.assign({}, msg)\n      const sequences = mbBasics.invalidSequencesIn(msg) ? node.sequences : msg.sequences\n\n      try {\n        sequences.forEach(msg => {\n          const inputMsg = node.prepareMsg(msg)\n          if (node.isValidModbusMsg(inputMsg)) {\n            const newMsg = node.buildNewMessageObject(node, inputMsg)\n            node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, inputMsg, newMsg))\n            modbusClient.emit('readModbus', newMsg, node.onModbusReadDone, node.onModbusReadError)\n          }\n        })\n      } catch (err) {\n        node.errorProtocolMsg(err, origMsgInput)\n        mbBasics.sendEmptyMsgOnFail(node, err, origMsgInput)\n      }\n\n      if (node.showStatusActivities) {\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\n      }\n    })\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      node.bufferMessageList.clear()\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-flex-sequencer', ModbusFlexSequencer)\n}\n"]}