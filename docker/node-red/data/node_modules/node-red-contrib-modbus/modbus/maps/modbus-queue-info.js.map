{"version":3,"sources":["modbus-queue-info.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusQueue","nodes","registerType","internalDebugLog","createNode","this","name","config","topic","unitid","parseInt","lowLowLevel","lowLevel","highLevel","highHighLevel","errorOnHighLevel","queueReadIntervalTime","showStatusActivities","updateOnAllQueueChanges","node","queueReadInterval","modbusClient","updateStatusRrunning","unitsWithQueue","Map","setNodeStatusTo","getNode","server","unit","set","resetStates","unitWithQueue","highLevelReached","highHighLevelReached","get","lowLowLevelReached","errorProtocolMsg","err","showErrors","logMsgError","initUnitQueueStates","msg","checkLowLevelReached","bufferCommandListLength","modbusClientName","now","state","checkHighLevelReached","payload","Date","warn","id","checkHighHighLevelReached","error","Error","getStatusSituationFillColor","fillColor","send","setNodeStatusByActivity","lowLevelReached","bufferCommands","Promise","resolve","status","fill","shape","reject","text","readFromQueue","length","checkQueueStates","readFromAllUnitQueues","registerModbusQueueActionsToNode","on","eventCallback","setInterval","bufferCommandList","removeListener","updateOnAllUnitQueues","queueEnabled","allQueueData","queues","resetQueue","removeModbusQueueActionsFromNode","sendEmptyMsgOnFail","msgQueueReset","settings","verbose","msgUnitId","unitId","queueOptions","queue","lowlowLevel","clearInterval","setNodeDefaultStatus","infoText","done","deregisterForModbus"],"mappings":"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","file":"../modbus-queue-info.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Read node.\n * @module NodeRedModbusRead\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const mbBasics = require('./modbus-basics')\n  const coreModbusQueue = require('./core/modbus-queue-core')\n  const internalDebugLog = require('debug')('contribModbus:queue')\n\n  function ModbusQueueInfo (config) {\n    RED.nodes.createNode(this, config)\n\n    this.name = config.name\n    this.topic = config.topic\n    this.unitid = parseInt(config.unitid) || 1\n    this.lowLowLevel = parseInt(config.lowLowLevel)\n    this.lowLevel = parseInt(config.lowLevel)\n    this.highLevel = parseInt(config.highLevel)\n    this.highHighLevel = parseInt(config.highHighLevel)\n    this.errorOnHighLevel = config.errorOnHighLevel\n    this.queueReadIntervalTime = config.queueReadIntervalTime || 1000\n    this.showStatusActivities = config.showStatusActivities\n    this.updateOnAllQueueChanges = config.updateOnAllQueueChanges\n    this.updateOnAllUnitQueues = config.updateOnAllUnitQueues\n\n    this.internalDebugLog = internalDebugLog\n\n    const node = this\n    node.queueReadInterval = null\n    node.updateStatusRrunning = false\n    node.unitsWithQueue = new Map()\n    mbBasics.setNodeStatusTo('waiting', node)\n\n    const modbusClient = RED.nodes.getNode(config.server)\n    if (!modbusClient) {\n      return\n    }\n    modbusClient.registerForModbus(node)\n\n    node.initUnitQueueStates = function () {\n      for (let unit = 0; unit < 256; unit += 1) {\n        node.unitsWithQueue.set(unit, {})\n        node.resetStates(unit)\n      }\n    }\n\n    node.resetStates = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      unitWithQueue.lowLowLevelReached = true\n      unitWithQueue.lowLevelReached = false\n      unitWithQueue.highLevelReached = false\n      unitWithQueue.highHighLevelReached = false\n    }\n\n    node.errorProtocolMsg = function (err, msg) {\n      if (node.showErrors) {\n        mbBasics.logMsgError(node, err, msg)\n      }\n    }\n\n    node.initUnitQueueStates()\n\n    node.checkLowLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLevelReached && bufferCommandListLength > node.lowLowLevel && bufferCommandListLength < node.lowLevel) {\n        unitWithQueue.lowLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'low level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name,\n          bufferCommandListLength\n        }\n        node.send(msg)\n      }\n    }\n\n    node.checkHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highLevelReached &&\n        bufferCommandListLength > node.lowLevel &&\n        bufferCommandListLength > node.highLevel) {\n        unitWithQueue.highLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          bufferCommandListLength\n        }\n\n        if (node.errorOnHighLevel) {\n          node.error(new Error('Queue High Level Reached'), msg)\n        } else {\n          node.warn(msg)\n        }\n\n        node.send(msg)\n      }\n    }\n\n    node.checkHighHighLevelReached = function (node, bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.highHighLevelReached &&\n        bufferCommandListLength > node.highLevel &&\n        bufferCommandListLength > node.highHighLevel) {\n        unitWithQueue.highHighLevelReached = true\n        const msg = {\n          payload: Date.now(),\n          topic: node.topic,\n          state: 'high high level reached',\n          unitid: unit,\n          modbusClientName: modbusClient.name || modbusClient.id,\n          highLevel: node.highLevel,\n          highHighLevel: node.highHighLevel,\n          bufferCommandListLength\n        }\n        node.error(new Error('Queue High High Level Reached'), msg)\n        node.send(msg)\n      }\n    }\n\n    node.getStatusSituationFillColor = function (unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      let fillColor = 'blue'\n\n      if (unitWithQueue.lowLevelReached) {\n        fillColor = 'green'\n      }\n\n      if (unitWithQueue.highLevelReached) {\n        if (node.errorOnHighLevel) {\n          fillColor = 'red'\n        } else {\n          fillColor = 'yellow'\n        }\n      }\n\n      if (unitWithQueue.highHighLevelReached) {\n        fillColor = 'red'\n      }\n\n      return fillColor\n    }\n\n    node.setNodeStatusByActivity = function (bufferCommandListLength, unit) {\n      if (node.showStatusActivities) {\n        node.status({\n          fill: node.getStatusSituationFillColor(node.unitid),\n          shape: 'ring',\n          text: (bufferCommandListLength) ? 'active unit ' + unit + ' queue items: ' + bufferCommandListLength : 'active (Unit-Id: ' + unit + ') empty'\n        })\n      }\n    }\n\n    node.readFromQueue = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n      const unit = ((node.unitid < 1 || node.unitid > 255)) ? 1 : node.unitid\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              const bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n              node.checkQueueStates(bufferCommandListLength, unit)\n              node.setNodeStatusByActivity(bufferCommandListLength, unit)\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      } else {\n        if (node.showStatusActivities) {\n          node.setNodeStatusByActivity(null, unit)\n        }\n      }\n    }\n\n    node.checkQueueStates = function (bufferCommandListLength, unit) {\n      const unitWithQueue = node.unitsWithQueue.get(unit)\n      if (!unitWithQueue.lowLowLevelReached && bufferCommandListLength < node.lowLowLevel) {\n        node.resetStates(unit)\n      }\n      node.checkLowLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighLevelReached(node, bufferCommandListLength, unit)\n      node.checkHighHighLevelReached(node, bufferCommandListLength, unit)\n    }\n\n    node.readFromAllUnitQueues = function () {\n      if (node.updateStatusRrunning) {\n        return\n      }\n\n      if (modbusClient.bufferCommands) {\n        return new Promise(\n          function (resolve, reject) {\n            try {\n              node.updateStatusRrunning = true\n              let bufferCommandListLength = 0\n              for (let unit = 0; unit < 256; unit += 1) {\n                bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\n                if (!bufferCommandListLength) {\n                  continue\n                }\n                node.checkQueueStates(bufferCommandListLength, unit)\n              }\n              node.updateStatusRrunning = false\n              resolve()\n            } catch (err) {\n              node.updateStatusRrunning = false\n              reject(err)\n            }\n          })\n      }\n    }\n\n    node.registerModbusQueueActionsToNode = function (eventCallback) {\n      if (node.updateOnAllQueueChanges) { // much more CPU-Load on many parallel requests to the client\n        modbusClient.on('mbqueue', eventCallback) // en-queue\n      }\n      modbusClient.on('mbactive', eventCallback) // de-queue\n      modbusClient.on('mbinit', eventCallback)\n      modbusClient.on('mbconnected', eventCallback)\n      modbusClient.on('mberror', eventCallback)\n      modbusClient.on('mbclosed', eventCallback)\n      node.queueReadInterval = setInterval(eventCallback, node.queueReadIntervalTime)\n    }\n\n    node.removeModbusQueueActionsFromNode = function (eventCallback) {\n      modbusClient.removeListener('mbqueue', eventCallback)\n      modbusClient.removeListener('mbactive', eventCallback)\n      modbusClient.removeListener('mbinit', eventCallback)\n      modbusClient.removeListener('mbconnected', eventCallback)\n      modbusClient.removeListener('mberror', eventCallback)\n      modbusClient.removeListener('mbclosed', eventCallback)\n    }\n\n    if (node.updateOnAllUnitQueues) {\n      node.registerModbusQueueActionsToNode(node.readFromAllUnitQueues)\n      mbBasics.setNodeStatusTo('active for all queues', node)\n    } else {\n      node.registerModbusQueueActionsToNode(node.readFromQueue)\n    }\n\n    node.on('input', function (msg) {\n      let msgUnitId = node.unitid\n      msg.payload = {}\n      msg.payload.queueEnabled = modbusClient.bufferCommands\n\n      if (node.updateOnAllUnitQueues) {\n        msg.payload.allQueueData = true\n        msg.payload.queues = modbusClient.bufferCommandList\n      } else {\n        try {\n          if (msg.payload.resetQueue) {\n            msgUnitId = parseInt(msg.payload.unitId) || node.unitid\n          } else {\n            msgUnitId = parseInt(msg.payload) || node.unitid\n          }\n        } catch (err) {\n          node.errorProtocolMsg(err, msg)\n          mbBasics.sendEmptyMsgOnFail(node, err, msg)\n          msgUnitId = node.unitid\n        }\n        msg.payload.allQueueData = false\n        msg.payload.unitid = msgUnitId\n        msg.payload.queue = modbusClient.bufferCommandList.get(msgUnitId)\n      }\n\n      msg.payload.queueOptions = {\n        date: Date.now(),\n        state: 'queue request',\n        modbusClientName: modbusClient.name || modbusClient.id,\n        lowlowLevel: node.lowlowLevel,\n        unitId: msgUnitId,\n        lowLevel: node.lowLevel,\n        highLevel: node.highLevel,\n        highHighLevel: node.highHighLevel\n      }\n\n      const msgQueueReset = msg.payload.resetQueue || msg.resetQueue\n      if (msgQueueReset && modbusClient.bufferCommands) {\n        coreModbusQueue.initQueue(modbusClient)\n        if (RED.settings.verbose) {\n          const infoText = 'Init Queue By External Node'\n          modbusClient.warn(infoText)\n          internalDebugLog(infoText)\n        }\n        node.initUnitQueueStates()\n\n        if (node.showStatusActivities) {\n          node.status({\n            fill: 'blue',\n            shape: 'ring',\n            text: 'active empty unit queue'\n          })\n        }\n        msg.payload.queueOptions.state = 'queue reset done'\n      }\n\n      node.send(msg)\n    })\n\n    node.on('close', function (done) {\n      if (node.updateOnAllUnitQueues) {\n        node.removeModbusQueueActionsFromNode(node.readFromAllUnitQueues)\n      } else {\n        node.removeModbusQueueActionsFromNode(node.readFromQueue)\n      }\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.queueReadInterval) {\n        clearInterval(node.queueReadInterval)\n      }\n      node.queueReadInterval = null\n      modbusClient.deregisterForModbus(node.id, done)\n    })\n\n    if (!node.showStatusActivities) {\n      mbBasics.setNodeDefaultStatus(node)\n    }\n  }\n\n  RED.nodes.registerType('modbus-queue-info', ModbusQueueInfo)\n}\n"]}