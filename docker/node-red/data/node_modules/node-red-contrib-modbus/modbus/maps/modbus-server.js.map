{"version":3,"sources":["modbus-server.js"],"names":["module","exports","RED","install","modbus","require","net","nodes","registerType","config","internalDebugLog","this","name","logEnabled","hostname","serverPort","parseInt","responseDelay","delayUnit","holdingBufferSize","bufferFactor","inputBufferSize","discreteBufferSize","showErrors","verboseLogging","node","netServer","settings","verbose","mbBasics","setNodeStatusTo","modbusLogLevel","logLabel","holding","alloc","input","discrete","Buffer","logLevel","modbusServer","on","calc_rateByUnit","coils","client","socket","showStatusActivities","JSON","stringify","address","remoteAddress","remotePort","error","err","message","warn","coreServer","isValidMemoryMessage","msg","buildMessage","payload","type","writeToServerMemory","send","isValidMessage","disableMsgOutput","done","close"],"mappings":"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","file":"../modbus-server.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus - The BSD 3-Clause License\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n **/\n\n/**\n * Modbus Server node.\n * @module NodeRedModbusServer\n *\n * @param RED\n */\nmodule.exports = function (RED) {\n  'use strict'\n  require('source-map-support').install()\n  const modbus = require('jsmodbus')\n  const net = require('net')\n  const coreServer = require('./core/modbus-server-core')\n  const mbBasics = require('./modbus-basics')\n  const internalDebugLog = require('debug')('contribModbus:server')\n\n  function ModbusServer (config) {\n    RED.nodes.createNode(this, config)\n\n    const bufferFactor = 8\n\n    this.name = config.name\n    this.logEnabled = config.logEnabled\n    this.hostname = config.hostname || '0.0.0.0'\n    this.serverPort = parseInt(config.serverPort)\n    this.responseDelay = parseInt(config.responseDelay) || 1\n    this.delayUnit = config.delayUnit\n\n    this.coilsBufferSize = parseInt(config.coilsBufferSize * bufferFactor)\n    this.holdingBufferSize = parseInt(config.holdingBufferSize * bufferFactor)\n    this.inputBufferSize = parseInt(config.inputBufferSize * bufferFactor)\n    this.discreteBufferSize = parseInt(config.discreteBufferSize * bufferFactor)\n\n    this.showErrors = config.showErrors\n    this.internalDebugLog = internalDebugLog\n    this.verboseLogging = RED.settings.verbose\n\n    const node = this\n\n    node.netServer = null\n    node.modbusServer = null\n\n    mbBasics.setNodeStatusTo('initialized', node)\n\n    let modbusLogLevel = 'warn'\n    if (RED.settings.verbose) {\n      modbusLogLevel = 'debug'\n    }\n\n    try {\n      node.netServer = new net.Server()\n      node.modbusServer = new modbus.server.TCP(node.netServer, {\n        logLabel: 'ModbusServer',\n        logLevel: modbusLogLevel,\n        logEnabled: node.logEnabled,\n        responseDelay: mbBasics.calc_rateByUnit(node.responseDelay, node.delayUnit),\n        coils: Buffer.alloc(node.coilsBufferSize, 0),\n        holding: Buffer.alloc(node.holdingBufferSize, 0),\n        input: Buffer.alloc(node.inputBufferSize, 0),\n        discrete: Buffer.alloc(node.discreteBufferSize, 0)\n      })\n\n      node.modbusServer.on('connection', function (client) {\n        internalDebugLog('Modbus Server client connection')\n        if (client && client.socket) {\n          internalDebugLog('Modbus Server client to ' + JSON.stringify(client.socket.address()) + ' from ' + client.socket.remoteAddress + ' ' + client.socket.remotePort)\n        }\n        mbBasics.setNodeStatusTo('active', node)\n      })\n\n      node.netServer.listen(node.serverPort, node.hostname, () => {\n        internalDebugLog('Modbus Server listening on modbus://' + node.hostname + ':' + node.serverPort)\n        mbBasics.setNodeStatusTo('initialized', node)\n      })\n\n      if (!node.showStatusActivities) {\n        mbBasics.setNodeDefaultStatus(node)\n      }\n    } catch (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.warn(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    }\n\n    node.netServer.on('error', function (err) {\n      internalDebugLog(err.message)\n      if (node.showErrors) {\n        node.error(err)\n      }\n      mbBasics.setNodeStatusTo('error', node)\n    })\n\n    node.on('input', function (msg) {\n      if (coreServer.isValidMemoryMessage(msg)) {\n        coreServer.writeToServerMemory(node, msg)\n        if (!msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      } else {\n        if (node.showErrors) {\n          node.error('Is Not A Valid Memory Write Message To Server', msg)\n        }\n        if (coreServer.isValidMessage(msg) && !msg.payload.disableMsgOutput) {\n          node.send(buildMessage(msg))\n        }\n      }\n    })\n\n    function buildMessage (msg) {\n      return [\n        { type: 'holding', message: msg, payload: node.modbusServer.holding },\n        { type: 'coils', message: msg, payload: node.modbusServer.coils },\n        { type: 'input', message: msg, payload: node.modbusServer.input },\n        { type: 'discrete', message: msg, payload: node.modbusServer.discrete },\n        { payload: 'request', type: 'message', message: msg }\n      ]\n    }\n\n    node.on('close', function (done) {\n      mbBasics.setNodeStatusTo('closed', node)\n      if (node.netServer) {\n        node.netServer.close(() => {\n          internalDebugLog('Modbus Server closed')\n          done()\n        })\n      }\n      node.modbusServer = null\n    })\n  }\n\n  try {\n    RED.nodes.registerType('modbus-server', ModbusServer)\n  } catch (err) {\n    internalDebugLog(err.message)\n  }\n}\n"]}