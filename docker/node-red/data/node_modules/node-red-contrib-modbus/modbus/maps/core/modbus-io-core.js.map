{"version":3,"sources":["core/modbus-io-core.js"],"names":["require","install","de","biancoroyal","modbus","io","core","internalDebug","LineByLineReader","nameValuesFromIOFile","node","msg","values","response","readingOffset","valueNames","ioCore","ioFile","configData","mapping","addressOffset","Number","logIOActivities","valueAddress","startsWith","insertValues","buildOutputAddressMapping","allValueNamesFromIOFile","ioNode","convertValuesByType","forEach","buildInputAddressMapping","push","getDataTypeFromFirstCharType","type","registerName","offset","logging","addressStartIO","addressStart","coilStart","bits","bitAddress","addressType","substring","registerType","split","Math","floor","register","name","addressOffsetIO","registerAddress","Bit","dataType","error","item","index","call","JSON","stringify","isRegisterSizeWrong","value","pow","getValueFromBufferByDataType","bufferOffset","responseBuffer","registerLength","length","readUInt16BE","convertedValue","readInt8","readInt16BE","readFloatBE","readDoubleBE","readUInt8","readUInt32BE","readUIntBE","sixteenBitBufferLength","buffer","err","filter","startRegister","endRegister","adr","functionType","message","sizeDivisor","fc","quantity","origMsg","start","topic","rawMsg","payload","allValueNames","valueName","filterValueNames","useIOForPayload","buildMessageWithIO","this","getOriginalMessage","bufferMessageList","modbusRequest","Object","assign","useIOFile","lastUpdatedAt","parseInt","address","module","exports"],"mappings":"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","file":"../../core/modbus-io-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\n// eslint-disable-next-line no-var\nvar de = de || { biancoroyal: { modbus: { io: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.internalDebug = de.biancoroyal.modbus.io.core.internalDebug || require('debug')('contribModbus:io:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.LineByLineReader = de.biancoroyal.modbus.io.core.LineByLineReader || require('line-by-line') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.io.core.core = de.biancoroyal.modbus.io.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.io.core.nameValuesFromIOFile = function (node, msg, values, response, readingOffset) {\n  let valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (node.ioFile && node.ioFile.configData) {\n    node.ioFile.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\n      }\n    })\n  }\n\n  valueNames = ioCore.insertValues(valueNames, values, node.logIOActivities)\n\n  return ioCore.convertValuesByType(valueNames, values, response, node.logIOActivities)\n}\n\nde.biancoroyal.modbus.io.core.allValueNamesFromIOFile = function (ioNode) {\n  const valueNames = []\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  if (ioNode && ioNode.configData) {\n    ioNode.configData.forEach(function (mapping) {\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(ioNode.addressOffset), 0))\n      }\n    })\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getDataTypeFromFirstCharType = function (type) {\n  switch (type) {\n    case 'w':\n      return 'Word'\n    case 'd':\n      return 'Double'\n    case 'r':\n      return 'Real'\n    case 'f':\n      return 'Float'\n    case 'i':\n      return 'Integer'\n    case 'l':\n      return 'Long'\n    case 'b':\n      return 'Boolean'\n    default:\n      return 'Unsigned Integer'\n  }\n}\n\nde.biancoroyal.modbus.io.core.buildInputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%IX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown input type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart,\n      addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart,\n      bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'input'\n    }\n  }\n\n  return { name: mapping.name, type, mapping, error: 'variable name does not match input mapping' }\n}\n\nde.biancoroyal.modbus.io.core.buildOutputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let addressStart = 0\n  let coilStart = 0\n  let addressOffset = 0\n  let bits = 0\n  let bitAddress = null\n\n  const type = mapping.name.substring(0, 1)\n  const registerType = mapping.valueAddress.substring(2, 3)\n  const addressType = mapping.valueAddress.substring(0, 3)\n\n  switch (type) {\n    case 'w': // word\n    case 'u': // unsigned integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 1\n      bits = 16\n      break\n    case 'i': // integer\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n\n      if (registerType === 'W') {\n        addressOffset = 1\n        bits = 16\n      } else {\n        addressOffset = 2\n        bits = 32\n      }\n      break\n    case 'r': // real\n    case 'f': // float\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 2\n      bits = 32\n      break\n    case 'd': // double\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 4\n      bits = 64\n      break\n    case 'l': // long\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\n      addressOffset = 5\n      bits = 80\n      break\n    case 'b': // bit - boolean\n      if (registerType === 'X') {\n        bitAddress = mapping.valueAddress.split('%QX')[1].split('.')\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\n        addressOffset = 1\n        bits = 1\n      }\n      break\n    default:\n      if (logging) {\n        ioCore.internalDebug('unknown output type ' + type)\n      }\n      bits = 0\n  }\n\n  if (bits) {\n    const addressStartIO = addressStart - (Number(offset) || 0)\n\n    return {\n      register: registerName,\n      name: mapping.name,\n      addressStart,\n      addressOffset,\n      addressOffsetIO: Number(offset) || 0,\n      addressStartIO,\n      registerAddress: addressStartIO - Number(readingOffset),\n      coilStart,\n      bitAddress,\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\n      bits,\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\n      type: 'output'\n    }\n  }\n\n  return { name: mapping.name, type, mapping, error: 'variable name does not match output mapping' }\n}\n\nde.biancoroyal.modbus.io.core.insertValues = function (valueNames, register, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n\n  let index = 0\n  for (index in valueNames) {\n    const item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Insert Value ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    switch (Number(item.bits)) {\n      case 1:\n        item.value = !!((register[item.registerAddress] & Math.pow(item.bitAddress[1], 2)))\n        break\n      case 16:\n        item.value = register[item.registerAddress]\n        break\n      case 32:\n        item.value = register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 64:\n        item.value = register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      case 80:\n        item.value = register[item.registerAddress + 4] << 64 |\n          register[item.registerAddress + 3] << 48 |\n          register[item.registerAddress + 2] << 32 |\n          register[item.registerAddress + 1] << 16 |\n          register[item.registerAddress]\n        break\n      default:\n        item.value = null\n        break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.getValueFromBufferByDataType = function (item, bufferOffset, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  const registerLength = responseBuffer.length / 2\n\n  if (bufferOffset < 0 || bufferOffset > responseBuffer.length) {\n    if (logging) {\n      ioCore.internalDebug('Wrong Buffer Access Parameter Type:' + item.dataType + ' Register-Length: ' + registerLength +\n        ' Buffer-Length:' + responseBuffer.length + ' Address-Buffer-Offset:' + bufferOffset)\n      ioCore.internalDebug(JSON.stringify(item))\n    }\n    return item\n  }\n\n  if (logging) {\n    ioCore.internalDebug('Get Value From Buffer By Data Type:' + item.dataType + ' Register:' + item.registerAddress + ' Bits:' + Number(item.bits))\n  }\n\n  switch (item.dataType) {\n    case 'Boolean':\n      item.value = !!(responseBuffer.readUInt16BE(bufferOffset) & Math.pow(item.bitAddress[1], 2))\n      break\n    case 'Word':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset) // DWord\n          item.convertedValue = false\n      }\n      break\n    case 'Integer':\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readInt16BE(bufferOffset)\n      }\n      break\n    case 'Real':\n    case 'Float':\n      item.value = responseBuffer.readFloatBE(bufferOffset, 4)\n      break\n    case 'Double':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 8)\n      break\n    case 'Long':\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 10)\n      break\n    default:\n      switch (item.bits) {\n        case '8':\n          item.value = responseBuffer.readUInt8(bufferOffset)\n          break\n        case '32':\n          item.value = responseBuffer.readUInt32BE(bufferOffset)\n          break\n        case '64':\n          item.value = responseBuffer.readUIntBE(bufferOffset, 8)\n          break\n        default:\n          item.value = responseBuffer.readUInt16BE(bufferOffset)\n          item.convertedValue = false\n      }\n      break\n  }\n\n  return item\n}\n\nde.biancoroyal.modbus.io.core.convertValuesByType = function (valueNames, register, responseBuffer, logging) {\n  const ioCore = de.biancoroyal.modbus.io.core\n  let bufferOffset = 0\n  const sixteenBitBufferLength = 2\n\n  let index = 0\n  for (index in valueNames) {\n    let item = valueNames[index]\n\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'dataType') || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\n      if (logging) {\n        ioCore.internalDebug('Item Not Valid To Convert ' + JSON.stringify(item))\n      }\n      continue\n    }\n\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\n      if (logging) {\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\n      }\n      break\n    }\n\n    if (responseBuffer.buffer instanceof Buffer) {\n      bufferOffset = Number(item.registerAddress) * sixteenBitBufferLength\n      try {\n        item = ioCore.getValueFromBufferByDataType(item, bufferOffset, responseBuffer.buffer, logging)\n      } catch (err) {\n        ioCore.internalDebug(err.message)\n      }\n    } else {\n      if (logging) {\n        ioCore.internalDebug('Response Buffer Is Not A Buffer')\n      }\n      break\n    }\n  }\n\n  return valueNames\n}\n\nde.biancoroyal.modbus.io.core.filterValueNames = function (node, valueNames, fc, adr, quantity) {\n  if (!valueNames.length || !valueNames.filter) {\n    return valueNames\n  }\n\n  const ioCore = de.biancoroyal.modbus.io.core\n  let functionType = 'input'\n\n  if (fc === 2 || fc === 4) {\n    functionType = 'output'\n  }\n\n  const startRegister = adr\n  const endRegister = Number(adr) + Number(quantity) - 1\n\n  if (node.logIOActivities) {\n    ioCore.internalDebug('adr:' + adr + ' quantity:' + quantity + ' startRegister:' + startRegister + ' endRegister:' + endRegister + ' functionType:' + functionType)\n  }\n\n  return valueNames.filter((valueName) => {\n    return (valueName.registerAddress >= 0 &&\n      valueName.addressStartIO >= startRegister &&\n      valueName.addressStartIO <= endRegister &&\n      valueName.type === functionType)\n  })\n}\n\nde.biancoroyal.modbus.io.core.isRegisterSizeWrong = function (register, start, bits) {\n  const sizeDivisor = Number(bits) || 16\n  const startRegister = Number(start)\n  let endRegister = startRegister\n\n  if (sizeDivisor > 16) {\n    endRegister = startRegister + (sizeDivisor / 16) - 1\n  }\n\n  return (startRegister < 0 || register.length < startRegister || endRegister > register.length)\n}\n\nde.biancoroyal.modbus.io.core.buildMessageWithIO = function (node, values, response, msg) {\n  const origMsg = this.core.getOriginalMessage(node.bufferMessageList, msg)\n  origMsg.modbusRequest = Object.assign({}, msg.payload)\n  origMsg.payload = values\n  origMsg.topic = msg.topic\n  origMsg.responseBuffer = response\n\n  const rawMsg = Object.assign({}, origMsg)\n  rawMsg.payload = response\n  rawMsg.values = values\n  delete rawMsg.responseBuffer\n\n  if (node.useIOFile && node.ioFile.lastUpdatedAt) {\n    const allValueNames = this.nameValuesFromIOFile(node, msg, values, response, parseInt(msg.payload.address) || 0)\n    const valueNames = this.filterValueNames(node, allValueNames, parseInt(msg.payload.fc) || 3,\n      parseInt(msg.payload.address) || 0,\n      parseInt(msg.payload.quantity) || 1,\n      node.logIOActivities)\n\n    if (node.useIOForPayload) {\n      origMsg.payload = valueNames\n      origMsg.values = values\n    } else {\n      origMsg.payload = values\n      origMsg.valueNames = valueNames\n    }\n\n    rawMsg.valueNames = valueNames\n    return [origMsg, rawMsg]\n  } else {\n    return [origMsg, rawMsg]\n  }\n}\n\nmodule.exports = de.biancoroyal.modbus.io.core\n"]}