{"version":3,"sources":["core/modbus-queue-core.js"],"names":["require","install","de","biancoroyal","modbus","queue","core","internalDebug","initQueue","node","bufferCommandList","clear","sendingAllowed","unitSendingAllowed","step","set","checkQueuesAreEmpty","queuesAreEmpty","get","length","queueSerialUnlockCommand","this","name","id","queueSerialLockCommand","serialSendingAllowed","resolve","reject","sequentialDequeueCommand","Promise","queueCore","unitId","parallelUnitIdsAllowed","shift","isValidUnitId","queueLog","JSON","stringify","type","sendQueueDataToModbus","infoText","warn","queueLength","command","callModbus","cb","Error","msg","cberr","commandDelay","state","value","dequeueCommand","delay","then","dequeueLogEntry","getUnitIdToQueue","parseInt","payload","err","message","unit_id","pushToQueueByUnitId","coreQueue","queueLengthByUnitId","info","getQueueLengthByUnitId","clienttype","push","exports","module"],"mappings":"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","file":"../../core/modbus-queue-core.js","sourcesContent":["/**\n Copyright (c) 2016,2017,2018,2019,2020,2021,2022 Klaus Landsdorf (http://node-red.plus/)\n All rights reserved.\n node-red-contrib-modbus\n node-red-contrib-modbusio\n\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\n */\n'use strict'\nrequire('source-map-support').install()\n\n// eslint-disable-next-line no-var\nvar de = de || { biancoroyal: { modbus: { queue: { core: {} } } } } // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.internalDebug = de.biancoroyal.modbus.queue.core.internalDebug || require('debug')('contribModbus:queue:core') // eslint-disable-line no-use-before-define\nde.biancoroyal.modbus.queue.core.core = de.biancoroyal.modbus.queue.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\n\nde.biancoroyal.modbus.queue.core.initQueue = function (node) {\n  node.bufferCommandList.clear()\n  node.sendingAllowed.clear()\n  node.unitSendingAllowed = []\n\n  for (let step = 0; step <= 255; step++) {\n    node.bufferCommandList.set(step, [])\n    node.sendingAllowed.set(step, true)\n  }\n}\n\nde.biancoroyal.modbus.queue.core.checkQueuesAreEmpty = function (node) {\n  let queuesAreEmpty = true\n  for (let step = 0; step <= 255; step++) {\n    queuesAreEmpty &= (node.bufferCommandList.get(step).length === 0)\n  }\n  return queuesAreEmpty\n}\n\nde.biancoroyal.modbus.queue.core.queueSerialUnlockCommand = function (node) {\n  this.internalDebug('queue serial unlock command node name: ' + node.name + ' id: ' + node.id)\n  node.serialSendingAllowed = true\n}\n\nde.biancoroyal.modbus.queue.core.queueSerialLockCommand = function (node) {\n  this.internalDebug('queue serial lock command node name: ' + node.name + ' id: ' + node.id)\n  node.serialSendingAllowed = false\n}\n\nde.biancoroyal.modbus.queue.core.sequentialDequeueCommand = function (node) {\n  this.internalDebug('sequential de-queue command')\n  return new Promise(\n    function (resolve, reject) {\n      const queueCore = de.biancoroyal.modbus.queue.core\n\n      if (node.parallelUnitIdsAllowed) {\n        for (let unitId = 0; unitId < 256; unitId += 1) {\n          queueCore.sendQueueDataToModbus(node, unitId)\n        }\n      } else {\n        const unitId = node.unitSendingAllowed.shift()\n        if (!queueCore.isValidUnitId(unitId)) {\n          reject(new Error('UnitId ' + unitId + ' is not valid from dequeue of sending list'))\n          return\n        }\n\n        node.queueLog(JSON.stringify({\n          type: 'sequential dequeue command',\n          unitId,\n          isValidUnitId: queueCore.isValidUnitId(unitId),\n          sendingAllowed: node.sendingAllowed.get(unitId),\n          serialSendingAllowed: node.serialSendingAllowed\n        }))\n\n        if (queueCore.isValidUnitId(unitId) &&\n          node.sendingAllowed.get(unitId)) {\n          queueCore.sendQueueDataToModbus(node, unitId)\n        } else {\n          node.warn('sequential dequeue command not possible for Unit ' + unitId)\n          let infoText = 'sending is allowed for Unit '\n          if (node.sendingAllowed.get(unitId)) {\n            node.warn(infoText + unitId)\n          } else {\n            node.warn('no ' + infoText + unitId)\n          }\n          infoText = 'valid Unit '\n          if (queueCore.isValidUnitId(unitId)) {\n            node.warn(infoText + unitId)\n          } else {\n            node.warn('no ' + infoText + unitId)\n          }\n          infoText = ' serial sending allowed for Unit '\n          if (node.serialSendingAllowed) {\n            node.warn(node.name + infoText + unitId)\n          } else {\n            node.warn(node.name + ' no' + infoText + unitId)\n          }\n        }\n      }\n      resolve()\n    })\n}\n\nde.biancoroyal.modbus.queue.core.sendQueueDataToModbus = function (node, unitId) {\n  const queueLength = node.bufferCommandList.get(unitId).length\n  node.queueLog(JSON.stringify({\n    type: 'send queue data to Modbus',\n    unitId,\n    queueLength,\n    sendingAllowed: node.sendingAllowed.get(unitId),\n    serialSendingAllowed: node.serialSendingAllowed\n  }))\n\n  if (queueLength) {\n    const command = node.bufferCommandList.get(unitId).shift()\n    if (command) {\n      node.sendingAllowed.set(unitId, false)\n      command.callModbus(node, command.msg, command.cb, command.cberr)\n    } else {\n      throw new Error('Command On Send Not Valid')\n    }\n  }\n}\n\nde.biancoroyal.modbus.queue.core.dequeueLogEntry = function (node, state, info) {\n  node.queueLog(JSON.stringify({\n    state: state.value,\n    message: `${info} ${node.clienttype}`,\n    delay: node.commandDelay\n  }))\n}\n\nde.biancoroyal.modbus.queue.core.dequeueCommand = function (node) {\n  const queueCore = de.biancoroyal.modbus.queue.core\n  const state = node.actualServiceState\n\n  if (node.messageAllowedStates.indexOf(state.value) === -1) {\n    queueCore.dequeueLogEntry(node, state, 'dequeue command disallowed state')\n  } else {\n    queueCore.sequentialDequeueCommand(node).then(function () {\n      queueCore.dequeueLogEntry(node, state, 'dequeue command done')\n    }).catch(function (err) {\n      queueCore.dequeueLogEntry(node, state, 'dequeue command error ' + err.message)\n    })\n  }\n}\n\nde.biancoroyal.modbus.queue.core.getUnitIdToQueue = function (node, msg) {\n  return parseInt(msg.payload.unitid) || parseInt(node.unit_id) || 0\n}\n\nde.biancoroyal.modbus.queue.core.isValidUnitId = function (unitId) {\n  return (unitId >= 0 && unitId <= 255)\n}\n\nde.biancoroyal.modbus.queue.core.getQueueLengthByUnitId = function (node, unitId) {\n  if (this.isValidUnitId(unitId)) {\n    return node.bufferCommandList.get(unitId).length\n  } else {\n    throw new Error('(0-255) Got A Wrong Unit-Id: ' + unitId)\n  }\n}\n\nde.biancoroyal.modbus.queue.core.pushToQueueByUnitId = function (node, callModbus, msg, cb, cberr) {\n  const coreQueue = de.biancoroyal.modbus.queue.core\n\n  return new Promise(\n    function (resolve, reject) {\n      try {\n        const unitId = coreQueue.getUnitIdToQueue(node, msg)\n        if (!coreQueue.isValidUnitId(unitId)) {\n          reject(new Error('UnitId ' + unitId + ' is not valid from msg or node'))\n          return\n        } else {\n          node.queueLog(JSON.stringify({\n            info: 'will push to Queue by Unit-Id',\n            message: msg.payload,\n            unitId\n          }))\n        }\n        const queueLength = coreQueue.getQueueLengthByUnitId(node, unitId)\n\n        msg.queueLengthByUnitId = { unitId, queueLength }\n        msg.queueUnitId = unitId\n\n        if (!node.parallelUnitIdsAllowed || node.clienttype === 'serial') {\n          node.unitSendingAllowed.push(unitId)\n        }\n\n        node.bufferCommandList.get(unitId).push({ callModbus, msg, cb, cberr })\n        node.queueLog(JSON.stringify({\n          info: 'pushed to Queue by Unit-Id',\n          message: msg.payload,\n          unitId\n        }))\n        resolve()\n      } catch (err) {\n        reject(err)\n      }\n    })\n}\n\nmodule.exports = de.biancoroyal.modbus.queue.core\n"]}